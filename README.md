# ИДЗ №4 Вариант 18
## Амирханов Никита Русланович БПИ219

### Условия
Задача о болтунах. N болтунов имеют телефоны. Они либо ждут звон-
ков, либо звонят друг другу, чтобы побеседовать. Если телефон случайного
абонента занят, болтун будет звонить другому абоненту, пока ему кто-нибудь
не ответит. Побеседовав некоторое время, болтун или ждет звонка, или зво-
нит на другой случайный номер. Создать многопоточное приложение, мо-
делирующее поведение болтунов. Для решения задачи использовать мью-
тексы.

### Задание решено на 10 баллов.
 - Есть решение с использованием pthread
 - Есть консольный ввод-ввывод
 - Есть файловый ввод-ввывод
 - Есть генерация случайных значений
 - Есть комментарии к коду
 - Есть дополнительные 2 программы на openMP и MPI на требования 6 баллов


### Запуск приложения
#### Запуск программы с использованием `pthread`
 - Компиляция: `g++ pthread_main.cpp -o main -lpthread`
 - Запуск
 - - Консольный: `./main -c <количество болтунов>`
 - - Файловый: `./main -f <входной файл> <выходной файл>`
 - - Случайный: `./main -f <нижняя граница> <верхняя граница> <опционально выходной файл>`
При консольном вводе или случайном без указания файла, все события будут выводиться в консоль. Если же указан выходной файл, то все события будут записываться во временный вектор, а при правильной остановке программы (через ввод `q`) запипишутся в файл.
#### Запуск программы с использованием `openMP`
 - Компиляция: `g++ openmp_main.cpp -o main -fopenmp`
 - Запуск
 - - Консольный: `./main`
 - - Через командную строку: `./main <количество болтунов>`
В обоих случаях все события будут выводиться в консоль
#### Запуск программы с использованием `MPI`
 - Компиляция: `mpic++ mpi_main.cpp -o main`
 - Запуск: `mpirun -hostfile openmpi.host -np <количество потоков> main` 
Все события выводятся в консоль, количество создаваемых болтунов равно половине количества потоков при запуске

### Входные данные
Во всех случаях входныные данные - число N >= 2 - кол-во болтунов.
При четном количестве болтунов `./main -f test1.txt out.txt` или `./main -c 4` все болтуны будут задействованы в общении между собой по парам.
```
[start] 1 -> 3
[start] 2 -> 0
[status] (0 2 1) (3 1 2) (0 2 2) (3 1 1)
```
При нечетном количестве болтунов `./main -f test2.txt out.txt` или `./main -c 3` один из болтунов ничего не будет делать, так как для него нет пары.
```
[start] 2 -> 1
[status] (-1 -1 0) (1 2 1) (1 2 2)
```
Полный пример выходных данным можно увидеть в файле `example_out.txt`


### О программе (модель)
Для решения задачи была выбрана модель с общей памятью ([источник](http://www.ccas.ru/paral/prog/models.html)), где каждый поток имеет возможность читать/записывать в нее. В моем случае это `vector<talker_t>`. Для избежания ситуаций неуправляемого изменения одних и тех же общих данных несколькими потоками и их несогласованного поведения я использовал мьютексы, как было указано в задании. Перед чтением/записью доступ блокировался через `pthread_mutex_lock(&mutex);` а затем освобождался через `pthread_mutex_unlock(&mutex);`. Я разделил потоки на читателей и писателей, так как один болтун может как звонить другому, так и принимать звонок. Кроме того я добавил поток для завершения программы (`key_press_thread`) и поток для вывода состояния вектора (`observe`), для вывода более детальной информации о процессе.


### О программе (поведение сущностей)
Каждый болтун выбирает чебе случайного собеседника и пытается дозвониться ему, если ему удается, то он болтает с другим болтуном какое то время, почле чего ищет себе нового собеседника или получает звонок от другого болтуна.

### О программе (алгоритм)
Каждый болтун (`talker_t`) имеет свой статус (звонит, принимает звонок, в звонке, свободен) и свой индекс, который могут видеть другие болтуны. При любом событии этот статус изменяется. Все статусы лежат в общем векторе болтунов `talkers`, откуда все берут информацию. В начале звонка болтун в потоке `ringing` проверяет что: он не занят, планируемый собеседник не занят. Затем он выставляет статусы. После чего поток `answering` проверяет статусы болтунов, и начинает сам звонок который длится случайное время. После окончаения статусы обновляются и болтуны становялся свободный для следующих итераций.

### Особенности openMP
В программе на openMP вместо мьютексов использовалась критическая секция `#pragma omp critical`. В остальном логика программ схожа.

### Особенности MPI
Для программы на MPI логика программы изменилась. В ней нет общего вектора с болтунами, вместо этого болтуны договариваются о звонке между собой с помощью команд `MPI_Send` и `MPI_Recv`. Это сильно усложнило логику программы. Юолее подробно о процессе договаривания можно узнать из комментариев к коду. Кроме того при выводе сообщений о событиях при N потоках создается N/2 болтунов. Поэтому нумерация потоков такая: rank = 0 - главный управляющий поток, 0 < rank < N/2 - поток `ringing`, N/2 <= rank < N - поток `answering`.